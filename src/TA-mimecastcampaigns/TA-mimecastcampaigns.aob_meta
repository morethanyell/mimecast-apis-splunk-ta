{"basic_builder": {"appname": "TA-mimecastcampaigns", "friendly_name": "Mimecast Campaigns", "version": "2.0.0", "author": "morethanyell", "description": "Utilizes Mimecast Awareness Training API to pull data Campaigns / Phishing Simulation results data", "theme": "#010066", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAA7FJREFUWEftl21Mk1cUx3+XrrwM0W2wzsRsDESJiWERA8JAk8URw77MdtaRzKJBVvnA5hIHNGwzMSS2Y5qICjjky8ZLhBFlOoszMUVnovgCiiwxgWzJkI0YP4DocJv0WZ6n9GkrtVLQBJPeT+3Nuef8zv+e+5x7hcAsMYeGCAE9YTeeH4Uk5NJ6WuUVpuoiZqKQxASfl6xl4WsLZl3uTifcv3+Pc+f6cTj6gUhEgET9bpnEv1y+Us7KlUmzBkKSEELWRXD16m/o9VXcGhxX/vsbjwH6jytPC8g7qiRxo+8WKSlfIoicA0CTCHl5+2lp+dWvRkEpVFHRhkYTrmaWnhbPuzlv+WR67Oglbt4cVqtk9ZqlrM5O9myRJLFnr52SknYEnmJ3OwkKSIiPgOjJtQKLJROrdYsP0CbTQZoaeyfnJGLmCUbHvkV46dHWdhmjUZ7TTNm2IIFMwIuqE4slG6tVnvOMTaZqmhuvIykAEhEREg8e1PkU8bH2bgz6agQvzB5IeAGVWbKwWvP9ArlPUXiEMwQUUsjTh4SJUA3Jckj4bx0ipJD6fQ0p5HVw/Lw63DWUmproZRiGvxravVtuHe6bpcCUX0tz4zW1VShf6vE6XDdQeQjaf+wJtnU85JtKPa/H61QgTRgYjTUIIpQ52f2GD5Ixbsz2hBJQW3Oas51DgFOx02qdNDWbmXB6rsPXegax2ezT72WugBOP3Knlfu3bnSUlqCuwZ2h8OrvL18NHbKb6chs8s1dH+Rfv0dHRR0/3H1M6eqCJuQu0aNFLODp3kJSko/7wL7z8SjSLE1+lqbkLiyVXSSo2NpqBgdvEx8dSUPAdDQ0F3Llzj/BwDRUVJ0lOXkhu7nK2mRtp/cHMzp3HKSpag04Xw/z5UTQ0XMRkylDW/PXnKJWVP2P72sDJn3opKmpylbz7Kb11axaH6/MJE9tYkfoGdvsnyqLh4VHS0hPYtesENpuB7Z8eUeyq9p1h+2dr+XBjHS2tZqoPOlivX6E4lRMqKV3HqVN9GAypqo0b6OPC76nan0dZ2VEOHMhTkly65CtfoKQlOhyOHchKddj7SEt/k5GRvxnovx0Q6O7dccbG/uFQ7Vk2b8kkJiZS+S0DyQoUF7+jBIqLm6cq5Aaqqe4kITEOrVbD+vdrfIGCqjxg1aoELly0kJlho6vr98cuLy1dx9tZi8nJWaaoMDQ0EjDUjItaVrKwMJv6+vMBg8hAUVFajp/ondaJmzFQsIpO1z4E9CSl5pxC/wNe0TCbAKuEFgAAAABJRU5ErkJggg==", "visible": true, "tab_version": "4.2.0", "tab_build_no": "0", "build_no": 1}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "mc:at:phishcampaigns", "interval": "86400", "use_external_validation": true, "streaming_mode_xml": true, "name": "phishing_campaigns_result", "title": "Phishing Campaigns Result", "description": "Collects results of Phishing Campaigns", "type": "customized", "parameters": [{"name": "grid_url", "label": "Grid URL", "help_string": "Mimecast Grid API URL. E.g.: https://de-api.mimecast.com", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://de-api.mimecast.com"}, {"name": "app_id", "label": "App Id", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "167b3d9f-c3ed-4941-b629-148a862b994a"}, {"name": "app_key", "label": "App Key", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "db28e641-a634-46e3-8f6a-65a6a57cfb1f"}, {"name": "access_key", "label": "Access Key", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "mYtOL3XZCOwG96BOiFTZRkqewayGLqe8aLof4d_wfJnA5ANermTCy9uY0YxJ-27VHny5psGtrksfT8RuvesX4XkOWdWo2aNH1dl8EXqx1vPbBBP3DwLAq5J6suLiZDyOtTShb7J0wGae0oK2rDQkyg"}, {"name": "secret_key", "label": "Secret Key", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "qRZlM/RDknwgS3mr/tS1p1xVBctHaif7u8PyhG0QMOffquInv+qPqZDpNvjlHMBut2SgRALBACtWmOJqm5xQpg=="}, {"name": "campaign_parent_name", "label": "Campaign Name", "help_string": "Give a name to this campaign. E.g.: Q3 Phishing Simulation - Confirm iPhone 15 Pro Amazon Order", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "samsung galaxy aaaa"}, {"name": "campaign_launched_date", "label": "Campaign Launched Date", "help_string": "This collection will only ingest results made since this Campaign Launched Date. Format: YYYY-mm-ddTHH:MM:SS+0000", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "2024-03-11T00:00:00+0000"}, {"name": "campaign_end_date", "label": "Campaign End Date", "help_string": "This collection will only ingest results made before this Campaign End Date. Format: YYYY-mm-ddTHH:MM:SS+0000", "required": false, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "2024-03-12T00:00:00+0000"}, {"name": "include_all_user_data", "label": "Include All User Data", "help_string": "Check to ingest user activities made even after the Campaign End Date", "required": false, "format_type": "checkbox", "default_value": true, "type": "checkbox", "value": true}], "data_inputs_options": [{"type": "customized_var", "name": "grid_url", "title": "Grid URL", "description": "Mimecast Grid API URL. E.g.: https://de-api.mimecast.com", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "app_id", "title": "App Id", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "app_key", "title": "App Key", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "access_key", "title": "Access Key", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "secret_key", "title": "Secret Key", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "campaign_parent_name", "title": "Campaign Name", "description": "Give a name to this campaign. E.g.: Q3 Phishing Simulation - Confirm iPhone 15 Pro Amazon Order", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "campaign_launched_date", "title": "Campaign Launched Date", "description": "This collection will only ingest results made since this Campaign Launched Date. Format: YYYY-mm-ddTHH:MM:SS+0000", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "campaign_end_date", "title": "Campaign End Date", "description": "This collection will only ingest results made before this Campaign End Date. Format: YYYY-mm-ddTHH:MM:SS+0000", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "include_all_user_data", "title": "Include All User Data", "description": "Check to ingest user activities made even after the Campaign End Date", "required_on_edit": false, "required_on_create": false, "format_type": "checkbox", "default_value": true}], "code": "\n# encoding = utf-8\n\nimport json\nimport requests\nimport base64\nimport hashlib\nimport time\nimport hmac\nimport uuid\nimport datetime\nimport random\nimport gc\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    pass\n\ndef get_campaigns(helper, _grid_url, _access_key, _secret_key, _app_id, _app_key):\n\n    base_url = _grid_url\n    uri = \"/api/awareness-training/phishing/campaign/get-campaign\"\n    url = base_url + uri\n    access_key = _access_key\n    secret_key = _secret_key\n    app_id = _app_id\n    app_key = _app_key\n\n    request_id = str(uuid.uuid4())\n    hdr_date = datetime.datetime.utcnow().strftime(\"%a, %d %b %Y %H:%M:%S\") + \" UTC\"\n    dataToSign = ':'.join([hdr_date, request_id, uri, app_key])\n    hmac_sha1 = hmac.new(base64.b64decode(secret_key), dataToSign.encode(), digestmod=hashlib.sha1).digest()\n    sig = base64.b64encode(hmac_sha1).rstrip()\n\n    headers = {\n        'Authorization': 'MC ' + access_key + ':' + sig.decode(),\n        'x-mc-app-id': app_id,\n        'x-mc-date': hdr_date,\n        'x-mc-req-id': request_id,\n        'Content-Type': 'application/json'\n    }\n\n    payload = {\n        \"data\": []\n    }\n    \n    all_results = []\n    page = 1\n    max_retries = 10\n    retry_count = 0\n    \n    while url and retry_count < max_retries: \n        \n        response = requests.post(url=url, headers=headers, data=str(payload))\n        \n        if response.status_code == 200:\n            \n            all_results = response.json()\n            url = None\n            retry_count = 0\n            \n        elif response.status_code > 499:\n            \n            retry_count += 1\n            if retry_count < max_retries:\n                # Sleep for 10 seconds and then retry the request\n                helper.log_warning(f'API query failed due to http_status={response.status_code} error (Mimecast server error). Will retry for a maximum of 10x.')\n                time.sleep(10)\n            else:\n                helper.log_error(f'Failed after {max_retries} retries. Status code: {response.status_code}')\n                break\n            \n        else:\n            helper.log_error(f'Failed to retrieve campaigns summary data. Status code: {response.status_code}')\n            break\n    \n    return all_results\n    \ndef get_userdata(helper, _grid_url, _access_key, _secret_key, _app_id, _app_key, _campaignId, _pageToken):\n\n        base_url = _grid_url\n        uri = \"/api/awareness-training/phishing/campaign/get-user-data\"\n        url = base_url + uri\n        access_key = _access_key\n        secret_key = _secret_key\n        app_id = _app_id\n        app_key = _app_key\n\n        request_id = str(uuid.uuid4())\n        hdr_date = datetime.datetime.utcnow().strftime(\"%a, %d %b %Y %H:%M:%S\") + \" UTC\"\n        dataToSign = ':'.join([hdr_date, request_id, uri, app_key])\n        hmac_sha1 = hmac.new(base64.b64decode(secret_key), dataToSign.encode(), digestmod=hashlib.sha1).digest()\n        sig = base64.b64encode(hmac_sha1).rstrip()\n\n        headers = {\n            'Authorization': 'MC ' + access_key + ':' + sig.decode(),\n            'x-mc-app-id': app_id,\n            'x-mc-date': hdr_date,\n            'x-mc-req-id': request_id,\n            'Content-Type': 'application/json'\n        }\n\n        payload = {\n            'meta': {\n                \"pagination\": {\n                    \"pageSize\": 100,\n                    \"pageToken\": _pageToken\n                }\n            },\n            'data': [\n                {\n                    \"id\": _campaignId,\n                }\n            ]\n        }\n        \n        all_results = []\n        page = 1\n        max_retries = 10\n        retry_count = 0\n        \n        while url and retry_count < max_retries: \n            \n            response = requests.post(url=url, headers=headers, data=str(payload))\n            \n            if response.status_code == 200:\n                \n                all_results = response.json()\n                url = None\n                retry_count = 0\n                \n            elif response.status_code > 499:\n                \n                retry_count += 1\n                if retry_count < max_retries:\n                    # Sleep for 10 seconds and then retry the request\n                    helper.log_warning(f'API query failed due to http_status={response.status_code} error (Mimecast server error). Will retry for a maximum of 10x.')\n                    time.sleep(10)\n                else:\n                    helper.log_error(f'Failed after {max_retries} retries. Status code: {response.status_code}')\n                    break\n                \n            else:\n                helper.log_error(f'Failed to retrieve user data. Status code: {response.status_code}')\n                break\n        \n        return all_results\n        \ndef parse_campaign_dates(helper, date_str, ret_zero_if_err):\n    try:\n        return datetime.datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%S%z')\n    except ValueError as e:\n        helper.log_error(f'Date parsing encountered an error: {e}')\n        \n        if ret_zero_if_err:\n            return 0\n        else:\n            return None\n\ndef collect_events(helper, ew):\n    \n    stanzaname = helper.get_input_stanza_names()\n    grid_url = helper.get_arg('grid_url')\n    access_key = helper.get_arg('access_key')\n    secret_key = helper.get_arg('secret_key')\n    app_id = helper.get_arg('app_id')\n    app_key = helper.get_arg('app_key')\n    campaign_parent_name = helper.get_arg('campaign_parent_name')\n    campaign_launched_date = helper.get_arg('campaign_launched_date')\n    campaign_end_date = helper.get_arg('campaign_end_date')\n    include_all_user_data = helper.get_arg('include_all_user_data')\n    \n    # Phase 1: Date validation and parsing\n    \n    ld_epoch = parse_campaign_dates(helper, campaign_launched_date, False)\n    \n    if ld_epoch is None:\n        helper.log_warning(f'Failed to parse the configured Campaign Launched Date \"{campaign_launched_date}\". Revisit the Inputs configuration and double-check the format to have exactly: YYYY-mm-ddTHH:MM:SS+0000. This collection will not continue')\n        return 0\n    \n    ced_epoch = parse_campaign_dates(helper, campaign_end_date, False)\n    \n    if ced_epoch is None:\n        helper.log_warning(f'Failed to parse the configured Campaign End Date \"{campaign_end_date}\". Revisit the Inputs configuration and double-check the format to have exactly: YYYY-mm-ddTHH:MM:SS+0000. This collection will not continue')\n        return 0\n    \n    if ld_epoch > ced_epoch:\n        helper.log_error(f'Launched Date cannot be after the End Date. Skipping this scheduled collection.')\n        return 0\n    \n    # Phase 2: Phishing Campaign Summary and Result\n    \n    campaign_summary = get_campaigns(helper, grid_url, access_key, secret_key, app_id, app_key)\n    \n    if len(campaign_summary)==0 or campaign_summary is None:\n        helper.log_warning(f'No Phishing Campaigns data was retrieved. Exiting.')\n        return 0\n    \n    cs_err = \"\"\n    \n    if campaign_summary.get('fail', []):\n        cs_err = campaign_summary['fail'][0]['errors'][0]['message']\n    \n    if cs_err:\n        helper.log_error(f'Retrieving Campaigns Summary resulted to an error: {cs_err}. Exiting this collection.')\n        return 0\n    \n    helper.log_info(f'Retrieving Phishing Campaigns result/summary data.')\n    \n    ld_epoch_simple = datetime.datetime.strftime(ld_epoch, '%Y-%m-%d')\n    ed_epoch_simple = datetime.datetime.strftime(ced_epoch, '%Y-%m-%d')\n    \n    helper.log_info(f'Configuration: campaign_name=\"{campaign_parent_name}\" between launch_date={ld_epoch_simple} and end_date={ed_epoch_simple} all_users={include_all_user_data}')\n    \n    cs = campaign_summary.get('data')\n    \n    helper.log_info(f'A total of {len(cs)} Phishing Campaign summary results were retrieved.')\n    helper.log_info(f'Looping through all Phishing Campaigns to get user data. This may take some time...')\n    helper.log_info(f'Skipping campaigns outside of CLD and CED.')\n    \n    skip_ctr_campaigns = 0\n    skip_ctr_userdata = 0\n    \n    meta_source = f'mimecast_phishing_campaigns://{stanzaname}'\n    \n    for c in cs:\n        \n        this_c_name = c.get('name')\n        this_c_id = c.get('id')\n        this_c_launch_date = c.get('launchDate')\n        \n        this_c_launch_date_epoch = parse_campaign_dates(helper, this_c_launch_date, False)\n        \n        if this_c_launch_date_epoch is None:\n            helper.log_info(f'Skipping {this_c_name} because of failure to retrieve its launchDate property.')\n            skip_ctr_campaigns = skip_ctr_campaigns + 1\n            continue\n        \n        if this_c_launch_date_epoch < ld_epoch or this_c_launch_date_epoch > ced_epoch:\n            skip_ctr_campaigns = skip_ctr_campaigns + 1\n            continue\n        \n        data = json.dumps(c, separators=(',', ':'))\n        event = helper.new_event(source=meta_source, index=helper.get_output_index(), sourcetype='mc:at:phishcampaigns:summary', data=data)\n        ew.write_event(event)\n        \n        # Phase 3: Phishing Campaign User Data and Results\n        \n        next_page = \"\"\n\n        while next_page != \"n/a\":\n\n            user_data_result = get_userdata(helper, grid_url, access_key, secret_key, app_id, app_key, this_c_id, next_page)\n            \n            if len(user_data_result)==0 or user_data_result is None:\n                helper.log_info(f'No user data were retrieved from \"{this_c_name}\".')\n                continue\n            \n            if \"next\" in user_data_result.get('meta', {}).get('pagination', {}):\n                next_page = user_data_result.get('meta', {}).get('pagination', {}).get('next', 'n/a')\n            else:\n                next_page = \"n/a\"\n                \n            # Rather than collecting all user data in one JSON heap-resourced variable, we are\n            # ingesting every user data for every iteration to free up memory\n            \n            if random.random() < 0.03:\n                helper.log_info(f'TA-mimecastcampaigns is alive and is still collecting User Data...')\n            \n            for user_data in user_data_result[\"data\"]:\n                \n                for u in user_data[\"items\"]:\n                    \n                    zero_epoch = \"1970-01-01T00:00:00+0000\"\n                    \n                    time_clicked = parse_campaign_dates(helper, u.get('timeClicked', zero_epoch), True)\n                    time_opened = parse_campaign_dates(helper, u.get('timeOpened', zero_epoch), True)\n                    time_reported = parse_campaign_dates(helper, u.get('timeReported', zero_epoch), True)\n                    time_submitted = parse_campaign_dates(helper, u.get('timeSubmitted', zero_epoch), True)\n                    \n                    activity_timestamp = max(time_clicked, time_opened, time_reported, time_submitted, this_c_launch_date_epoch)\n                    \n                    if not include_all_user_data:\n                        if activity_timestamp > ced_epoch:\n                            skip_ctr_userdata = skip_ctr_userdata + 1\n                            continue\n                        \n                    outside_campaign_period = \"True\" if activity_timestamp > ced_epoch else \"False\"\n                        \n                    u[\"campaignId\"] = this_c_id\n                    u[\"campaignName\"] = this_c_name\n                    u[\"campaign\"] = campaign_parent_name\n                    u[\"launchDate\"] = this_c_launch_date\n                    u[\"campaignEndDate\"] = campaign_end_date\n                    u[\"activityTimestamp\"] = datetime.datetime.strftime(activity_timestamp, '%Y-%m-%dT%H:%M:%S%z')\n                    u[\"isOutsideCampaignPeriod\"] = outside_campaign_period\n                    \n                    data = json.dumps(u, separators=(',', ':'))\n                    event = helper.new_event(source=meta_source, index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n                    ew.write_event(event)\n            \n            user_data_result = None\n            gc.collect()\n                    \n    \n    helper.log_info(f'Skipped a total of {skip_ctr_campaigns} campaigns outside the configured launched and end date.')\n    \n    if not include_all_user_data:\n        helper.log_info(f'Skipped a total of {skip_ctr_userdata} user activities because the action (e.g. Click Time, Reported Time) date is beyond this Input\\'s configured Campaign End Date.')\n    \n    helper.log_info('End of collection. Reaching this part means a successful data collection.')\n    \n    ", "customized_options": [{"name": "grid_url", "value": "https://de-api.mimecast.com"}, {"name": "app_id", "value": "167b3d9f-c3ed-4941-b629-148a862b994a"}, {"name": "campaign_parent_name", "value": "samsung galaxy aaaa"}, {"name": "campaign_launched_date", "value": "2024-03-11T00:00:00+0000"}, {"name": "campaign_end_date", "value": "2024-03-12T00:00:00+0000"}, {"name": "include_all_user_data", "value": true}], "uuid": "4115f51f685b42dd8e985c054e6fb5d5", "sample_count": "86431"}]}, "field_extraction_builder": {"mc:at:phishcampaigns": {"data_format": "json"}, "mc:at:phishcampaigns:summary": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"log_settings": {}}}, "sourcetype_builder": {"mc:at:phishcampaigns": {"metadata": {"event_count": 0, "data_input_name": "phishing_campaigns_result", "extractions_count": 0, "cims_count": 0}}, "mc:at:phishcampaigns:summary": {"metadata": {"event_count": 0, "data_input_name": null, "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_started", "validation_id": "v_1721412735_88"}}